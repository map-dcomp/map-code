module protelis:com:bbn:map:resourcetracker

import com.bbn.protelis.networkresourcemanagement.ResourceSummary.getNullSummary
import com.bbn.protelis.networkresourcemanagement.ResourceSummary.merge
import com.bbn.protelis.networkresourcemanagement.ResourceSummary.convertToSummary

import com.bbn.protelis.networkresourcemanagement.ResourceReport.getShortEstimationWindow
import com.bbn.protelis.networkresourcemanagement.ResourceReport.getLongEstimationWindow

import com.bbn.protelis.networkresourcemanagement.LoadBalancerPlan.getNullLoadBalancerPlan
import com.bbn.protelis.networkresourcemanagement.RegionPlan.getNullRegionPlan

import com.bbn.map.NetworkAvailableServices.mergeNetworkAvailableServices
import com.bbn.map.NetworkAvailableServices.nullNetworkAvailableServices

import protelis:coord:sparsechoice
import protelis:coord:accumulation
import protelis:coord:spreading
import protelis:coord:meta
import protelis:lang:utils
import protelis:coord:nonselfstabilizing:accumulation
import protelis:state:nonselfstabilizing:time

import protelis:com:bbn:map:common

/**
 * Merge resource summaries.
 * 
 * @param a summary 1
 * @param b summary 2
 * @return the new merged summary
 */
def mergeSummaries(a,b) { merge(a,b); }

/**
 * Summarize the ResourceReports and elect a DCOP leader. 
 * @param rgn (RegionIdentifier) the region to create the summary for
 * @param localSummary (ResourceSummary) the local summary
 * @param window (EstimationWindow) the estimation window to summarize over
 * @return (ResourceSummary) the summary for the region, will only be complete on the DCOP node
 */
def summarizeReports(rgn, window, localSummary, leader) {
    let d = hopDistanceTo(leader);
    C(d, mergeSummaries, localSummary, getNullSummary(rgn, window))
}

/**
 * Collect all of the ResourceReport objects for a region.
 * 
 * @return (Tuple<ResourceReport>) the reports for the region, will only be complete on the leader node
 * @param leader (boolean) true if this is node is the one to receive all of the reports
 */
def collectReports(leader) {
    let d = hopDistanceTo(leader);
    C(d, union, [self.getController().getResourceReport(getShortEstimationWindow())], [])
}

/**
 * Collect all of the ServiceReport objects for a region.
 * 
 * @return (Tuple<ServiceReport>) the reports for the region, will only be complete on the leader node
 * @param leader (boolean) true if this is the one to receive all of the reports
 */
def collectServiceReports(leader) {
    let d = hopDistanceTo(leader);
    C(d, union, [self.getController().getServiceReport()], [])
}

/**
 * Make sure that all nodes in the region have the RLG plan.
 * 
 * @param rgn (RegionIdentifier) the region to work with
 * @param isRlgLeader (boolean) true if self is the RLG leader
 */
def disseminateRlgPlan(rgn, isRlgLeader) {
    let rlgPlan = self.getController().getNetworkState().getLoadBalancerPlan();
    let rlgBroadcastedPlan = broadcastObjectToRegion(rgn, isRlgLeader, rlgPlan);
    
    self.getController().apTraceMessage("Storing RLG plan of type: " + rlgBroadcastedPlan.getClass());   
    self.getController().getNetworkState().setLoadBalancerPlan(rlgBroadcastedPlan);
}

/**
 * Make sure that all nodes in the region have the DCOP plan.
 * 
 * @param rgn (RegionIdentifier) the region to work with
 * @param isDcopLeader (boolean) true if self is the DCOP leader
 */
def disseminateDcopPlan(rgn, isDcopLeader) {
    let dcopPlan = self.getController().getNetworkState().getRegionPlan();
    let dcopBroadcastedPlan = broadcastObjectToRegion(rgn, isDcopLeader, dcopPlan);
    
    self.getController().apTraceMessage("Storing DCOP plan of type: " + dcopBroadcastedPlan.getClass());   
    self.getController().getNetworkState().setRegionPlan(dcopBroadcastedPlan);
}

/**
 * Broadcast an object to all nodes in the specified region.
 * 
 * @param rgn (RegionIdentifier) the region 
 * @param isLeader (boolean) the leader node
 * @param obj (Object) the object to broadcast
 */
def broadcastObjectToRegion(rgn, isLeader, obj) {
    self.getController().apTraceMessage("Sending object to all nodes: " + obj + " leader: " + isLeader);
    multiRegion(rgn,(n) -> { rgn == n },
        () -> { 
            hopBroadcast(isLeader, obj);
        },
        obj);
}

/**
 * Compute the ResourceSummary for the specified estimation window and store the summary.
 * The complete summary will only be present on the node running DCOP.
 * 
 * @param rgn (RegionIdentifier) the region to summarize across
 * @param window (EstimationWindow) the estimation window to compute the summary for
 * @param isDcopLeader (boolean) true if this node is the DCOP leader
 */
def computeResourceSummary(rgn, window, isDcopLeader) {
    self.getController().apTraceMessage("Top of computeResourceSummary window: " + window);
    // summarize all reports for the region
    // Run the collection in the top-level so that we can get nbrs from other regions
    let localReport = self.getController().getResourceReport(window);
    self.getController().apTraceMessage("Local report serverLoad: " + localReport.getComputeLoad());
    let localSummary = self.convertToSummary(localReport);
    self.getController().apTraceMessage("Local summary serverLoad: " + localSummary.getServerLoad());
    
    let s = multiRegion(rgn,(n) -> { rgn == n },() -> {summarizeReports(rgn, window, localSummary, isDcopLeader)},[]);
    
    if(isDcopLeader) {    
        self.getController().apTraceMessage("Setting summary on " + self.getName() + " to " + s.getServerLoad() + " is DCOP: " + isDcopLeader + " localLoad: " + localSummary.getServerLoad());
        self.getController().getNetworkState().setRegionSummary(s);    
        self.getController().apTraceMessage("Bottom of computeResourceSummary window: " + window);
    } else {
        // nothing to do, need dummy statement though
        0;
    }
}

/**
 * Share DCOP shared information to all regions and store it as needed.
 * 
 * @param isDcopLeader (boolean) if this node is running DCOP
 * @param rgn (RegionIdentifier) the region for this node
 */
def shareDcopInformation(rgn, isDcopLeader)  {
    let nbrRegions = findNeighborRegions(isDcopLeader);
    
    let dcopShares = multiInstance(nbrRegions,
        (key) -> { 
            hopBroadcast(isDcopLeader && key==rgn, mux(isDcopLeader && key==rgn) {
                self.getController().getLocalDcopSharedInformation()
            }  else {
                // default to empty Tuple specifying that there is no information for the region
                // this value is filtered out in setAllDcopSharedInformation
                []
            });
        },
        []);
        
    if(isDcopLeader) {
        self.getController().apTraceMessage("Storing DCOP shared information of type: " + dcopShares.getClass());           
        self.getController().setAllDcopSharedInformation(dcopShares);    
    } else {
        // nothing to do, need dummy statement though
        0;
    }
}

/**
 * Share RLG shared information to all regions and store it as needed.
 * 
 * @param isRlgLeader (boolean) if this node is running RLG
 * @param rgn (RegionIdentifier) the region for this node
 */
def shareRlgInformation(rgn, isRlgLeader)  {
    let nbrRegions = findNeighborRegions(isRlgLeader);
    
    let rlgShares = multiInstance(nbrRegions,
        (key) -> {             
            hopBroadcast(isRlgLeader && key==rgn, mux(isRlgLeader && key==rgn) {
                self.getController().getLocalRlgSharedInformation()
            } else { 
                // default to empty Tuple specifying that there is no information for the region
                // this value is filtered out in setAllRlgSharedInformation
                []
            });
        },
        []);
        
    if(isRlgLeader) {
        self.getController().apTraceMessage("Storing RLG shared information of type: " + rlgShares.getClass());                   
        self.getController().setAllRlgSharedInformation(rlgShares);    
    } else {
        // nothing to do, need a dummy statement though
        0;
    }
}

def mergeNetworkAvailableServicesProtelis(a, b) {
  let ret = mergeNetworkAvailableServices(a, b);
  self.getController().apTraceMessage("calling mergeNetworkAvailableServices with " + a + " and " + b + " -> " + ret);
  ret;
}

def shareDnsInformation() {
    let globalLeader = false;
    if(self.getController().isUseLeaderElection()) {
        globalLeader = self.getController().isGlobalLeader();
    } else {
        globalLeader = electLeader();
        self.getController().setGlobalLeader(globalLeader);
    };    
    
    let cResult = C(hopDistanceTo(globalLeader), 
                    mergeNetworkAvailableServicesProtelis, 
                    self.getController().getLocalNetworkAvailableServices(), 
                    nullNetworkAvailableServices());
                    
    self.getController().apDebugMessage("global leader is: " + globalLeader + " cResult is: " + cResult);
                                        
    let allServices = hopBroadcast(globalLeader,cResult);
    
    self.getController().apTraceMessage("Storing all services of type: " + allServices.getClass());                      
    self.getController().setAllNetworkAvailableServices(allServices);    
} 

/**
 * Collect the service reports and store them on the DNS and RLG nodes.
 * 
 * @param leader true if this node is a leader for the service reports sharing
 * @param rgn (RegionIdentifier) the region for this node
 */
def shareServiceReports(rgn, leader) {
    // collect service reports on the RLG node and the DNS handler node
    // this actually sends the information to ALL nodes in the region
    // TODO: ticket:259 - limit the scope to just the DNS and RLG nodes
    let serviceReports = multiRegion(rgn,(n) -> { rgn == n },() -> {
        hopBroadcast(leader, collectServiceReports(leader));    
    },[]);
    self.getController().setRegionServiceReports(serviceReports);
}

// ---- main code

let neighbors = unionHood(nbr([self.getController().getDeviceUID()]));
self.getController().apDebugMessage("Neighbors protelis: " + neighbors + " java: " + self.getController().getNeighbors());

let rgn = self.getController().getRegionIdentifier();

let isDcopLeader = self.getController().isRunDCOP();
let isRlgLeader = self.getController().isRunRLG();
let isDnsHandler = self.getController().isHandleDnsChanges();

// compute the resource summary for all estimation windows
computeResourceSummary(rgn, getShortEstimationWindow(), isDcopLeader);
computeResourceSummary(rgn, getLongEstimationWindow(), isDcopLeader);


// collect all ResourceReport objects for this region
let r = multiRegion(rgn,(n) -> { rgn == n },() -> {collectReports(isRlgLeader)},[]);
self.getController().apTraceMessage("Storing region resource reports of type: " + r.getClass());
self.getController().setRegionResourceReports(r);


shareServiceReports(rgn, isRlgLeader);

disseminateRlgPlan(rgn, isRlgLeader);

disseminateDcopPlan(rgn, isDcopLeader);

shareDcopInformation(rgn, isDcopLeader);

shareRlgInformation(rgn, isRlgLeader);

shareDnsInformation();

// add some debugging output
self.getController().getExecutionEnvironment().put("blue",self.getController().isRLGRunning());
self.getController().getExecutionEnvironment().put("red",self.getController().isDCOPRunning());

// Value to report for debugging purposes:
//[s.getRegion(), r.size() + " Reports", s.getServerCapacity()]
//[s.getRegion(), r.size() + " Reports", s.getServerLoad(), s.getNetworkLoad()]
[rgn, "Num reports: " + r.size()]

//let report = self.getController().getResourceReport(getShortEstimationWindow());
//let d = report.getClientDemand();
//let c = report.getServerCapacity();
//[d,c,s];
